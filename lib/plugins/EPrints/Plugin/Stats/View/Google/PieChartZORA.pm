package EPrints::Plugin::Stats::View::Google::PieChartZORA;

use EPrints::Plugin::Stats::ViewZORA;
@ISA = ('EPrints::Plugin::Stats::ViewZORA');

use strict;
use Encode qw(encode);

# Stats::View::Google::PieChart
#
# Works in a similar way that View::Table except that it renders the data on a pie chart, generated by Google Charts

sub javascript_class { return 'GooglePieChart'; }

sub mimetype
{
	my( $self ) = @_;
	return "application/json";
}

sub render_title
{
        my( $self ) = @_;

	my $context = $self->context;
	
        my $grouping = defined $context->{grouping} ? ":".$context->{grouping} : "";

        return $self->html_phrase( "title$grouping" );
}

# same as Stats::View::Table
sub get_data
{
	my( $self ) = @_;
	my $session = $self->{session};

	# We need to know the Top <things> we're going to display...
	if( !EPrints::Utils::is_set( $self->options->{top} ) )
	{
		print "Stats::View::Google::PieChart: missing option 'top'\n";
		return $session->make_doc_fragment;
	}

	# This bit of code tries to map what the user wants to view given the context
	my $options = $self->options;
	
	$options->{do_render} = ( defined $options->{export} ) ? 0 : 1;

	$options->{limit} ||= 10;
	delete $options->{limit} if( $options->{limit} eq 'all' );

	my $top = $self->options->{top};

	# Perhaps the user wants to see the top:
	# - eprints
	# - <set_name> eg top authors
	# - <value> eg top referrers / country...
	if( $top eq 'eprint' )
	{
		# we need to fetch eprint objects ie 'eprintid'
		$self->context->{grouping} = 'eprint';
		$options->{fields} = [ 'eprintid' ];
	}
	elsif( $top eq $self->context->{datatype} )
	{
		$self->context->{grouping} = 'value';
		$options->{fields} = [ 'value' ];
	}
	elsif( EPrints::Utils::is_set( $self->context->{set_name} ) )
	{
		$self->context->{grouping} = $top;
		$options->{fields} = [ 'set_value' ];
	}
	else
	{
		# perhaps it's a set then... let's assume so!
		$self->context->{set_name} = $top;
		delete $self->context->{grouping};
		$options->{fields} = [ 'set_value' ];
	}

	$self->{options} = $options;

	return $self->handler->data( $self->context )->select( %$options );
}

sub render_content_ajax
{
	my( $self ) = @_;

        my $stats = $self->get_data;

	my $options = $self->options;

	my @full_labels;
	foreach( @{$stats->data} )
	{
		my $object = $_->{$options->{fields}->[0]};
		my $label = encode('utf-8', EPrints::XML::to_string( $object ));
		my $count = $_->{count};

		push @full_labels, "[ \"".$label."\", ".$count."]";
	}

	my $jsdata = join(",",@full_labels);

	# UZH CHANGE ZORA-627 2018/02/09/mb specific render method for slices
	my $chart_options = "\"options\": { \"slices\": [] }";

	if ( defined $options->{slice_color_set} )
	{
		$chart_options = $self->render_slices( $options->{slice_color_set} ) ;
	}

	print STDOUT "{ \"data\": [$jsdata], $chart_options }";
	# END UZH CHANGE ZORA-627

	return;
}


# UZH CHANGE ZORA-627 2018/02/09/mb
sub render_slices
{
	my ($self, $slice_color_set ) = @_;

	my $session = $self->{session};
	my $colormap = $session->config( $slice_color_set );

	my $additional_options;
	my $color;
	my @color_labels;
	
	my $stats = $self->get_data;
	
	my @sorted_data = sort { {$b}->{count} <=> {$a}->{count} } @{$stats->data};
	foreach my $datapoint ( @sorted_data )
	{
		my $object_str = encode( 'utf-8', EPrints::XML::to_string( $datapoint->{value} ) );
		if ( defined $colormap->{$object_str} )
		{
		
			$color = $colormap->{$object_str};
		}
		else
		{
			$color = 'lightgrey';
		}
		push @color_labels, "{\"color\":\"".  $color ."\"}";
	}

	my $slice_data = join(",",@color_labels);

	$additional_options = "\"options\": { \"slices\": [" . $slice_data . "] }";

	return $additional_options;
}

1;
